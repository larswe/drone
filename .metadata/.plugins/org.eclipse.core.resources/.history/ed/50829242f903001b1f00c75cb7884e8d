/*
 * HeatmapGenerator
 * 
 * Version 0.0.1-SNAPSHOT
 * 
 * 01-10-2020
 * 
 * Lars Werne, s1824086
 * 
 */

package uk.ac.ed.inf.heatmap;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.mapbox.geojson.*;


public class HeatmapGenerator {
	
	private static final int NUM_ROWS = 10;
	private static final int NUM_COLS = 10;
	private static final int MIN_PREDICTION = 0;
	private static final int MAX_PREDICTION = 255;
	
	private static final double MIN_LONGITUDE = -3.192473;
	private static final double MAX_LONGITUDE = -3.184319;
	private static final double MIN_LATITUDE = 55.942617;
	private static final double MAX_LATITUDE = 55.946233;
	
	private static final String TARGET_JSON_FILE_NAME = "heatmap.geosjon";
	
	private static Map<Integer, String> qualityTierToRgb;
	static {
		qualityTierToRgb = new HashMap<>();
		qualityTierToRgb.put(0, "#00ff00");
		qualityTierToRgb.put(1, "#40ff00");
		qualityTierToRgb.put(2, "#80ff00");
		qualityTierToRgb.put(3, "#c0ff00");
		qualityTierToRgb.put(4, "#ffc000");
		qualityTierToRgb.put(5, "#ff8000");
		qualityTierToRgb.put(6, "#ff4000");
		qualityTierToRgb.put(7, "#ff0000");
	}
	
	/*
	 * Input: Name of a file containing 10 lines, where each line consists of 10 comma-separated numbers.
	 */
    public static void main(String[] args) {
    	if (args.length != 1) {
        	exitWithIllegalArgumentException("The application expected 1 argument but received " + args.length);
        }
    	
    	int[][] grid = readGrid(args[0]);
    	FeatureCollection fc = generateFeatureCollection(grid);
    	writeFeatureCollectionToFile(fc, TARGET_JSON_FILE_NAME);
    }


	private static int[][] readGrid(String fileName) {
    	BufferedReader reader = getReaderForFile(fileName);
    	
    	int[][] grid = new int[NUM_ROWS][NUM_COLS];
    	String predRowStr;
    	int rowIndex = 0;
    	try {
			while ((predRowStr = reader.readLine()) != null) {
				
				if (rowIndex >= NUM_ROWS) {
					exitWithIllegalArgumentException("The input file contains more than " + NUM_ROWS + " lines!");
				}
				
				String[] predRowStrArray = predRowStr.split(",");
				if (predRowStrArray.length != NUM_COLS) {
					exitWithIllegalArgumentException("Line " + (rowIndex+1) + " of the input file does not contain the required " + NUM_COLS + " predictions!");
				}
				 
				for (int j = 0; j < NUM_COLS; j++) {
					int x = Integer.parseInt(predRowStrArray[j]);
					if (x < MIN_PREDICTION || x > MAX_PREDICTION) {
						exitWithIllegalArgumentException("All predictions must lie between " + MIN_PREDICTION + " and " + MAX_PREDICTION);
					}
					grid[rowIndex][j] = x;
				}
				rowIndex++;
			}
		} catch (IOException | NumberFormatException e) {
			e.printStackTrace();
			System.exit(1);
		}  
    	
    	if (rowIndex < NUM_ROWS) {
    		exitWithIllegalArgumentException("The input file contains less than " + NUM_ROWS + " lines of predictions!");
    	}
    	
    	return grid;
    }
    
    
    private static BufferedReader getReaderForFile(String fileName) {
    	File file = new File(fileName);
    	BufferedReader reader = null;
    	try {
    		reader = new BufferedReader(new FileReader(file));
    	} catch (FileNotFoundException e) {
    		e.printStackTrace();
    		System.exit(1);
    	}
    	return reader;
    }
    
    
    private static void exitWithIllegalArgumentException(String errorMessage) {
    	IllegalArgumentException e = new IllegalArgumentException(errorMessage);
		e.printStackTrace();
		System.exit(1);
    }
    
    
    private static FeatureCollection generateFeatureCollection(int[][] grid) {
    	ArrayList<Feature> listOfRectFeatures = new ArrayList<Feature>();
    	
    	double rectWidth = (MAX_LONGITUDE - MIN_LONGITUDE) / NUM_COLS;
    	double rectHeight = (MAX_LATITUDE - MIN_LATITUDE) / NUM_ROWS;
    	
    	double currentLong, currentLat;
    	for (int i = 0; i < NUM_ROWS; i++) {
    		for (int j = 0; j < NUM_COLS; j++) {
    			currentLong = MIN_LONGITUDE + j*rectWidth;
    			currentLat = MAX_LATITUDE - i*rectHeight;
    			List<Point> rectCoordinates = genRectCoordinates(currentLong, currentLat, rectWidth, rectHeight);
    			
    			Polygon rectPolygon = Polygon.fromLngLats(List.of(rectCoordinates));
    			Geometry rectGeometry = (Geometry) rectPolygon;
    			Feature rectFeature = Feature.fromGeometry(rectGeometry);
    			String rectRgbString = getRgbStringForQuality(grid[i][j]);
    			rectFeature.addNumberProperty("fill-opacity", 0.75);
    			rectFeature.addStringProperty("rgb-string", rectRgbString);
    			rectFeature.addStringProperty("fill", rectRgbString);
    			listOfRectFeatures.add(rectFeature);
    		}
    	}
    	
		return FeatureCollection.fromFeatures(listOfRectFeatures);
	}
    
    
    private static String getRgbStringForQuality(int quality) {
    	int numTiers = qualityTierToRgb.size();
    	int qualityTier = (numTiers*quality) / (MAX_PREDICTION+1);
    	
    	return qualityTierToRgb.get(qualityTier);
	}


	public static List<Point> genRectCoordinates(double upperLeftLong, double upperLeftLat, double width, double height) {
    	Point upperLeftPoint = Point.fromLngLat(upperLeftLong, upperLeftLat);
		Point upperRightPoint = Point.fromLngLat(upperLeftLong+width, upperLeftLat);
		Point lowerRightPoint = Point.fromLngLat(upperLeftLong+width, upperLeftLat-height);
		Point lowerLeftPoint = Point.fromLngLat(upperLeftLong, upperLeftLat-height);
		
		return List.of(upperLeftPoint, upperRightPoint, lowerRightPoint, lowerLeftPoint, upperLeftPoint);
    }
	
	
	private static void writeFeatureCollectionToFile(FeatureCollection fc, String fileName) {
		String outputString = fc.toJson();
		
		try {
			FileWriter fileWriter = new FileWriter(fileName);
			PrintWriter printWriter = new PrintWriter(fileWriter);
			printWriter.print(outputString);
			printWriter.close();
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}
	}
}